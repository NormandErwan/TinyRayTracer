#include "Assets/Scripts/Ray.hlsl"
#include "Assets/Scripts/Sphere.hlsl"

#pragma kernel Render

#define FLT_MAX         3.402823466e+38 // Maximum representable floating-point number

// The number of threads per group.
static const uint2 GroupThreads = uint2(32, 32);

// The forward vector of the camera.
static const float3 Forward = float3(0, 0, 1);

// The camera's background color.
extern float4 BackgroundColor;

// The camera's height when in orthographic mode.
extern float OrthographicHeight;

// The spheres to render.
extern StructuredBuffer<Sphere> Spheres;

// The render texture of the camera.
extern RWTexture2D<float4> Texture;

// Render to the Texture.
[numthreads(GroupThreads.x, GroupThreads.y, 1)]
void Render(uint3 id : SV_DispatchThreadID)
{
    float2 size;
    float4 pixel = BackgroundColor;
    Texture.GetDimensions(size.x, size.y);

    Ray ray;
    ray.Origin = float3(id.xy / size.y * OrthographicHeight, 0);
    ray.Direction = Forward;

    uint spheresCount, spheresStride;
    Spheres.GetDimensions(spheresCount, spheresStride);

    float minDistance = FLT_MAX;
    for (uint i = 0; i < spheresCount; i++)
    {
        Sphere sphere = Spheres[i];

        float distance;
        float3 hitPoint;
        bool intersect = Intersect(ray, sphere, distance, hitPoint);
        if (intersect && distance < minDistance)
        {
            minDistance = distance;
            pixel = sphere.Material.Color;
        }
    }

    Texture[id.xy] = pixel;
}
